#include "temp.h"
/*******************************************************************************
* 函数名         : Delay1ms
* 函数功能		   : 延时函数
* 输入           : 无
* 输出         	 : 无
*******************************************************************************/

void Delay642us()		//@11.0592MHz
{
	unsigned char i, j;

	_nop_();
	_nop_();
	i = 7;
	j = 228;
	do
	{
		while (--j);
	} while (--i);
}

void Delay500us()		//@11.0592MHz
{
	unsigned char i, j;

	i = 6;
	j = 93;
	do
	{
		while (--j);
	} while (--i);
}
void Delay68us()		//@11.0592MHz
{
	unsigned char i, j;

	_nop_();
	_nop_();
	i = 1;
	j = 183;
	do
	{
		while (--j);
	} while (--i);
}
void Delay6us()		//@11.0592MHz
{
	unsigned char i;

	_nop_();
	_nop_();
	i = 13;
	while (--i);
}
void Delay48us()		//@11.0592MHz
{
	unsigned char i, j;

	_nop_();
	i = 1;
	j = 128;
	do
	{
		while (--j);
	} while (--i);
}
void Delay1ms()		//@11.0592MHz
{
	unsigned char i, j;

	_nop_();
	i = 11;
	j = 190;
	do
	{
		while (--j);
	} while (--i);
}
/*******************************************************************************
* 函数名         : Ds18b20Init
* 函数功能		   : 初始化
* 输入           : 无
* 输出         	 : 初始化成功返回1，失败返回0
*******************************************************************************/

unsigned char Ds18b20Init()
{
	unsigned int i;
	DSPORT=0;			 //将总线拉低480us~960us
  Delay642us();
	DSPORT=1;			//然后拉高总线，如果DS18B20做出反应会将在15us~60us后总线拉低
	i=0;
	while(DSPORT)	//等待DS18B20拉低总线
	{
		i++;
		if(i>10)//等待>5MS
			return 0;//初始化失败	
		Delay500us();
	}
	return 1;//初始化成功
}

/*******************************************************************************
* 函数名         : Ds18b20WriteByte
* 函数功能		   : 向18B20写入一个字节
* 输入           : com
* 输出         	 : 无
*******************************************************************************/

void Ds18b20WriteByte(unsigned char dat)
{
	unsigned int j;
	for(j=0;j<8;j++)
	{
		DSPORT=0;			//每写入一位数据之前先把总线拉低1us
		_nop_();
		DSPORT=dat&0x01; //然后写入一个数据，从最低位开始
    Delay68us();
		DSPORT=1;	//然后释放总线，至少1us给总线恢复时间才能接着写入第二个数值
		dat>>=1;
	}
}
/*******************************************************************************
* 函数名         : Ds18b20ReadByte
* 函数功能		   : 读取一个字节
* 输入           : com
* 输出         	 : 无
*******************************************************************************/


unsigned char Ds18b20ReadByte()
{
	unsigned char byte,bi;
	unsigned int j;	
	for(j=8;j>0;j--)
	{
		DSPORT=0;//先将总线拉低1us
		_nop_();
		DSPORT=1;//然后释放总线
    Delay6us();
		bi=DSPORT;	 //读取数据，从最低位开始读取
		/*将byte左移一位，然后与上右移7位后的bi，注意移动之后移掉那位补0。*/
		byte=(byte>>1)|(bi<<7);						  
    Delay48us();
	}				
	return byte;
}
/*******************************************************************************
* 函数名         : Ds18b20ChangTemp
* 函数功能		   : 让18b20开始转换温度
* 输入           : com
* 输出         	 : 无
*******************************************************************************/

void  Ds18b20ChangTemp()
{
	Ds18b20Init();
	Delay1ms();
	Ds18b20WriteByte(0xcc);		//跳过ROM操作命令		 
	Ds18b20WriteByte(0x44);	    //温度转换命令
//	Delay1ms(100);	//等待转换成功，而如果你是一直刷着的话，就不用这个延时了
   
}
/*******************************************************************************
* 函数名         : Ds18b20ReadTempCom
* 函数功能		   : 发送读取温度命令
* 输入           : com
* 输出         	 : 无
*******************************************************************************/

void  Ds18b20ReadTempCom()
{	

	Ds18b20Init();
	Delay1ms();
	Ds18b20WriteByte(0xcc);	 //跳过ROM操作命令
	Ds18b20WriteByte(0xbe);	 //发送读取温度命令
}
/*******************************************************************************
* 函数名         : Ds18b20ReadTemp
* 函数功能		   : 读取温度
* 输入           : com
* 输出         	 : 无
*******************************************************************************/

int Ds18b20ReadTemp()
{
	int temp=0;
	unsigned char tmh,tml;
	Ds18b20ChangTemp();			 	//先写入转换命令
	Ds18b20ReadTempCom();			//然后等待转换完后发送读取温度命令
	tml=Ds18b20ReadByte();		//读取温度值共16位，先读低字节
	tmh=Ds18b20ReadByte();		//再读高字节
	temp=tmh;
	temp<<=8;
	temp|=tml;
	return temp;
}

void Temp_Result(unsigned char* Buff)
{
	  float tp;
	  int temp;
	  temp = Ds18b20ReadTemp();  
	  if(temp< 0)				//当温度值为负数
  	{
			Buff[0] = '-';
		//因为读取的温度是实际温度的补码，所以减1，再取反求出原码
		temp=temp-1;
		temp=~temp;
		tp=temp;
		temp=tp*0.0625*100+0.5;	
		//留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
		//后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
		//算由?.5，还是在小数点后面。
  	}
 	else
  	{	
    Buff[0] = '+';			
		tp=temp;//因为数据处理有小数点所以将温度赋给一个浮点型变量
		//如果温度是正的那么，那么正数的原码就是补码它本身
		temp=tp*0.0625*100+0.5;	
		//留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
		//后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
		//算加上0.5，还是在小数点后面。
	  }
	Buff[1] = temp / 10000 + 0x30;
	Buff[2] = temp % 10000 / 1000 + 0x30;
	Buff[3] = temp % 1000 / 100 + 0x30;
	Buff[4] = '.';	
	Buff[5] = temp % 100 / 10 + 0x30;
	Buff[6] = temp % 10 + 0x30;
}



