
sbit DQ = P3^4;                // 定义DQ引脚为P2.2

/*******************************  延时函数 ********************************
*  功能：在11.059MHz的晶振条件下调用本函数需要24μs ，然后每次计数需16μs 
**************************************************************************/
void DS18_delay(int useconds) {
int s;
for (s=0; s<useconds;s++);
}


/*******************************  复位函数 *******************************
* 功能：完成单总线的复位操作。
* 复位时间为480μs，因此延时时间为(480-24)/16 = 28.5，取29μs。
* 经过70μs之后检测存在脉冲，因此延时时间为(70-24)/16 = 2.875，取3μs。
**************************************************************************/
unsigned char ow_reset(void) {
unsigned char presence;
DQ = 0;  			// 将 DQ 线拉低
DS18_delay(29); 			// 保持 480μs
DQ = 1; 			// DQ返回高电平
DS18_delay(3); 			// 等待存在脉冲
presence = DQ; 		// 获得存在信号
DS18_delay(25); 			// 等待时间隙结束
return(presence); 	// 返回存在信号，0 = 器件存在, 1 = 无器件
}


/****************************** 位写入函数 *******************************
* 功能：向单总线写入1位值：bitval
*************************************************************************/
void write_bit(char bitval) {
DQ = 0; 				// 将DQ 拉低开始写时间隙
if(bitval==1) DQ =1; 	// 如果写1，DQ 返回高电平
DS18_delay(5); 				// 在时间隙内保持电平值，
DQ = 1; 	// DS18_delay函数每次循环延时16μs，因此DS18_delay(5) = 104μs
}	


/**************************** 字节写入函数 *******************************
* 功能：向单总线写入一个字节值：val
*************************************************************************/
void ds18write_byte(char val) {
unsigned char i;
unsigned char temp;
for (i=0; i<8; i++) {	// 写入字节, 每次写入一位 
temp = val>>i; 		
temp &= 0x01; 		
write_bit(temp); 
}
DS18_delay(5);
}

/**************************** 位读取函数 ********************************
* 功能：从单总线上读取一位信号，所需延时时间为15μs，因此无法调用前面定义
* 的DS18_delay()函数，而采用一个for()循环来实现延时。
* ***********************************************************************/
unsigned char read_bit(void) {
unsigned char i;
DQ = 0;     		 //将DQ 拉低开始读时间隙
DQ = 1; 			// then return high
for (i=0; i<3; i++); 	// 延时15μs
return(DQ); 			// 返回 DQ 线上的电平值
}

/**************************** 字节读取函数 *******************************
* 功能：从单总线读取一个字节的值
*************************************************************************/
unsigned char DSread_byte(void) {
unsigned char i;
unsigned char value = 0;
for (i=0;i<8;i++) {  				// 读取字节，每次读取一个字节
if(read_bit()) value|=0x01<<i; 	// 然后将其左移
DS18_delay(6); 					
}
return(value);
}


/******************************* 读取温度函数 *****************************
* 功能：如果单总线节点上只有一个器件则可以直接掉用本函数。如果节点上有多个器
*      件，为了避免数据冲突，应使用Match ROM函数来选中特定器件。
* 注： 本函数是根据DS1820的温度数据格式编写的，若用于DS18B20，必须根据
*      DS18B20的温度数据格式作适当修改。
**************************************************************************/unsigned 
int ReadTemperature(void) 
{
unsigned char get[10];
unsigned char temp_lsb,temp_msb;
unsigned int t;
unsigned char k;
ow_reset();
ds18write_byte(0xCC); 					// 跳过 ROM
ds18write_byte(0x44); 					// 启动温度转换
DS18_delay(5);
ow_reset();
ds18write_byte(0xCC); 					// 跳过 ROM
ds18write_byte(0xBE); 					// 读暂存器
for (k=0;k<2;k++){get[k]=DSread_byte();}

temp_msb = get[1]; // Sign byte + lsbit
temp_lsb = get[0]; // Temp data plus lsb

t=temp_msb*256+temp_lsb;
t=t&0x0ff0;
if(t<0xff&&t>0xf0)
t=(-1)*t;
return t>>4;
//temp_f = (((int)temp_c)* 9)/5 + 32;
		 // 输出华氏温度值

}

