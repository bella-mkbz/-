C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: D:\keil C51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\mai
                    -n.lst) TABS(2) OBJECT(..\Output\main.obj)

line level    source

   1          #include "string.h"
   2          #include "delay.h"
   3          #include "uart.h"
   4          #include "temp.h"
   5          
   6          #define Buf1_Max 60             //´®¿Ú1»º´æ³¤¶È
   7          #define Buf2_Max 200            //´®¿Ú2»º´æ³¤¶È
   8          
   9          
  10          /*************  ±¾µØ±äÁ¿ÉùÃ÷  **************/
  11          xdata u8 Uart1_Buf[Buf1_Max];
  12          xdata u8 Uart2_Buf[Buf2_Max];
  13          unsigned char Password[5] = "0806";
  14          xdata unsigned char phone[14 ] = "\"15086396076\"";
  15          static unsigned char *content = "Warning!!  Temperature: ";     
  16          unsigned char Datas_Buff[8]= {0, 0, 0, 0, 0, 0, 0,'\0'};
  17          u8 Times=0,First_Int = 0,shijian=0;
  18          //u8 Time_count=0;
  19          bdata u8 Flag;//¶¨Ê±Æ÷±êÖ¾Î»
  20          sbit Timer0_start =Flag^0;  //¶¨Ê±Æ÷0ÑÓÊ±Æô¶¯¼ÆÊýÆ÷
  21          sbit Uart2_Start  =Flag^1;  //´®¿Ú2¿ªÊ¼½ÓÊÕÊý¾Ý
  22          sbit Uart2_End    =Flag^2;  //´®¿Ú2½ÓÊÕÊý¾Ý½áÊø
  23          
  24          
  25          /*************  ±¾µØº¯ÊýÉùÃ÷  **************/
  26          void GPIO_config(void);
  27          void Timer0Init(void);
  28          void CLR_Buf2(void);
  29          u8 Find(u8 *a);
  30          void Set_Text_Mode(void);
  31          void Check_New_Message(void);
  32          void Wait_CREG(void);
  33          void Sec_AT_Command(u8 *b,u8 *a,u8 wait_time);
  34          void Send_Text_Sms(void);
  35          void Temp_Change(int temp,unsigned char* Buff);
  36          /*************  Íâ²¿º¯ÊýºÍ±äÁ¿ÉùÃ÷*****************/
  37          
  38          
  39          /*******************************************************************************
  40          * º¯ÊýÃû : main 
  41          * ÃèÊö   : Ö÷º¯Êý
  42          * ÊäÈë   : 
  43          * Êä³ö   : 
  44          * ·µ»Ø   : 
  45          * ×¢Òâ   : ´®¿Ú2¸ºÔðÓëGPRSÄ£¿éÍ¨ÐÅ£¬´®¿Ú1ÓÃÓÚ´®¿Úµ÷ÊÔ£¬¿ÉÒÔ±ÜÃâÔÚÏÂÔØ³ÌÐòÊ±Êý¾Ý
  46                     »¹·¢ËÍµ½Ä£¿é
  47          *******************************************************************************/
  48          void main(void)
  49          {
  50   1        int i = 0, send_flag = 0;
  51   1        GPIO_config();
  52   1        Uart1Init();
  53   1        Uart2Init();
  54   1        Timer0Init();
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 2   

  55   1        EA=1; //¿ª×ÜÖÐ¶Ï
  56   1        UART1_SendString("GPRSÄ£¿é¶ÌÐÅ²âÊÔ³ÌÐò\r\n");
  57   1        UART1_SendString("GPRSÄ£¿éÔÚ×¢²áÍøÂç\r\n");
  58   1        Wait_CREG();
  59   1        UART1_SendString("GPRSÄ£¿é×¢²á³É¹¦\r\n");
  60   1        UART1_SendString("GPRSÄ£¿é¶ÌÐÅÄ£Ê½ÉèÖÃ\r\n");
  61   1        Set_Text_Mode();
  62   1        UART1_SendString("ÉèÖÃ³É¹¦£¬¶ÌÐÅÄ£Ê½£ºTEXT\r\n");
  63   1        
  64   1        UART1_SendString("³õÊ¼»¯Íê³É\r\n");
  65   1        
  66   1        for(i=0;i<3;i++)
  67   1        {
  68   2          Temp_Change(Ds18b20ReadTemp(),Datas_Buff);
  69   2          delay_ms(500);  
  70   2        }
  71   1        
  72   1        while(1)
  73   1        {
  74   2          //Check_New_Message();
  75   2          Temp_Change(Ds18b20ReadTemp(),Datas_Buff);
  76   2          delay_ms(500); 
  77   2          UART1_SendString(Datas_Buff);
  78   2          if(((Datas_Buff[2] - 0x30)*10 + Datas_Buff[3] - 0x30) >= 25)
  79   2            send_flag++;
  80   2          if(send_flag == 1)
  81   2          {
  82   3            Send_Text_Sms();
  83   3          }
  84   2        }
  85   1        
  86   1      }
  87          
  88          /*******************************************************************************
  89          * º¯ÊýÃû : Uart1 
  90          * ÃèÊö   : ´®¿Ú1ÖÐ¶Ï·þÎñÈë¿Úº¯Êý
  91          * ÊäÈë   : 
  92          * Êä³ö   : 
  93          * ·µ»Ø   : 
  94          * ×¢Òâ   : 
  95          *******************************************************************************/
  96          void Uart1() interrupt 4
  97          {
  98   1          if (RI)
  99   1          {
 100   2              RI = 0;                 //Çå³ýRIÎ»
 101   2          }
 102   1          if (TI)
 103   1          {
 104   2              TI = 0;                 //Çå³ýTIÎ»
 105   2          }
 106   1      }
 107          
 108          /*******************************************************************************
 109          * º¯ÊýÃû : Uart2
 110          * ÃèÊö   : ´®¿Ú2ÖÐ¶Ï·þÎñÈë¿Úº¯Êý
 111          * ÊäÈë   : 
 112          * Êä³ö   : 
 113          * ·µ»Ø   : 
 114          * ×¢Òâ   : 
 115          *******************************************************************************/
 116          void Uart2() interrupt 8
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 3   

 117          {
 118   1          IE2  &= ~0x01;   //¹Ø±Õ´®¿Ú2ÖÐ¶Ï
 119   1          if (S2CON & S2RI)
 120   1          {
 121   2            S2CON &= ~S2RI;         //Çå³ýS2RIÎ»
 122   2            Uart2_Buf[First_Int] = S2BUF;     //½«½ÓÊÕµ½µÄ×Ö·û´®´æµ½»º´æÖÐ
 123   2            First_Int++;                      //»º´æÖ¸ÕëÏòºóÒÆ¶¯
 124   2            if(First_Int > Buf2_Max)          //Èç¹û»º´æÂú,½«»º´æÖ¸ÕëÖ¸Ïò»º´æµÄÊ×µØÖ·
 125   2            {
 126   3              First_Int = 0;
 127   3            }
 128   2          }
 129   1          if (S2CON & S2TI)
 130   1          {
 131   2            S2CON &= ~S2TI;         //Çå³ýS2TIÎ»
 132   2          }
 133   1          IE2  |= 0x01;   //Ê¹ÄÜ´®¿Ú2ÖÐ¶Ï
 134   1      }
 135          /*******************************************************************************
 136          * º¯ÊýÃû : Timer0_ISR
 137          * ÃèÊö   : ¶¨Ê±Æ÷0ÖÐ¶Ï·þÎñÈë¿Úº¯Êý,20msÖÐ¶ÏÒ»´Î
 138          * ÊäÈë   : 
 139          * Êä³ö   : 
 140          * ·µ»Ø   : 
 141          * ×¢Òâ   : 
 142          *******************************************************************************/
 143          void Timer0_ISR() interrupt 1
 144          {
 145   1        TR0=0;//¹Ø¶¨Ê±Æ÷
 146   1        if(Timer0_start)
 147   1        Times++;
 148   1        if(Times > (50*shijian))
 149   1        {
 150   2          Timer0_start = 0;
 151   2          Times = 0;
 152   2        }
 153   1        TR0=1;//¿ª¶¨Ê±Æ÷
 154   1      }
 155          /*******************************************************************************
 156          * º¯ÊýÃû : GPIO_config
 157          * ÃèÊö   : IO¿ÚÅäÖÃº¯Êý
 158          * ÊäÈë   : 
 159          * Êä³ö   : 
 160          * ·µ»Ø   : 
 161          * ×¢Òâ   : 
 162          *******************************************************************************/
 163          void  GPIO_config(void)
 164          {
 165   1          P3M1 &= 0XC3;  //ÅäÖÃP32~P35ÎªÍÆÍìÊä³ö
 166   1          P3M0 |= ~0XC3;
 167   1      }
 168          void Timer0Init(void)   //20ºÁÃë@22.1184MHz
 169          {
 170   1        AUXR &= 0x7F; //12TÄ£Ê½
 171   1        TMOD &= 0xF0; //ÉèÖÃ¶¨Ê±Æ÷Ä£Ê½ 16Î»ÖØÔØ
 172   1        TL0 = 0x00;   //Éè¶¨¶¨Ê±Æ÷³õÖµ
 173   1        TH0 = 0x70;   //Éè¶¨¶¨Ê±Æ÷³õÖµ
 174   1        TF0 = 0;      //Çå³ýTF0±êÖ¾
 175   1        TR0 = 1;      //¶¨Ê±Æ÷0¿ªÊ¼¼ÆÊ±
 176   1        ET0 = 1;      //Ê¹ÄÜ¶¨Ê±Æ÷0ÖÐ¶Ï
 177   1      }
 178          /*******************************************************************************
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 4   

 179          * º¯ÊýÃû : CLR_Buf2
 180          * ÃèÊö   : Çå³ý´®¿Ú2»º´æÊý¾Ý
 181          * ÊäÈë   : 
 182          * Êä³ö   : 
 183          * ·µ»Ø   : 
 184          * ×¢Òâ   : 
 185          *******************************************************************************/
 186          void CLR_Buf2(void)
 187          {
 188   1        u16 k;
 189   1        for(k=0;k<Buf2_Max;k++)      //½«»º´æÄÚÈÝÇåÁã
 190   1        {
 191   2          Uart2_Buf[k] = 0x00;
 192   2        }
 193   1          First_Int = 0;              //½ÓÊÕ×Ö·û´®µÄÆðÊ¼´æ´¢Î»ÖÃ
 194   1      }
 195          
 196          /*******************************************************************************
 197          * º¯ÊýÃû : Find
 198          * ÃèÊö   : ÅÐ¶Ï»º´æÖÐÊÇ·ñº¬ÓÐÖ¸¶¨µÄ×Ö·û´®
 199          * ÊäÈë   : 
 200          * Êä³ö   : 
 201          * ·µ»Ø   : unsigned char:1 ÕÒµ½Ö¸¶¨×Ö·û£¬0 Î´ÕÒµ½Ö¸¶¨×Ö·û 
 202          * ×¢Òâ   : 
 203          *******************************************************************************/
 204          
 205          u8 Find(u8 *a)
 206          { 
 207   1        if(strstr(Uart2_Buf,a)!=NULL)
 208   1            return 1;
 209   1        else
 210   1            return 0;
 211   1      }
 212          
 213          /*******************************************************************************
 214          * º¯ÊýÃû : Second_AT_Command
 215          * ÃèÊö   : ·¢ËÍATÖ¸Áîº¯Êý
 216          * ÊäÈë   : ·¢ËÍÊý¾ÝµÄÖ¸Õë¡¢·¢ËÍµÈ´ýÊ±¼ä(µ¥Î»£ºS)
 217          * Êä³ö   : 
 218          * ·µ»Ø   : 
 219          * ×¢Òâ   : 
 220          *******************************************************************************/
 221          
 222          void Sec_AT_Command(u8 *b,u8 *a,u8 wait_time)         
 223          {
 224   1        u8 i;
 225   1        u8 *c;
 226   1        c = b;                  
 227   1        CLR_Buf2(); 
 228   1        i = 0;
 229   1        while(i == 0)                    
 230   1        {
 231   2          if(!Find(a))          
 232   2          {
 233   3            if(Timer0_start == 0)
 234   3            {
 235   4              b = c;          
 236   4              for (b; *b!='\0';b++)
 237   4              {
 238   5                UART2_SendData(*b);
 239   5              }
 240   4              UART2_SendLR(); 
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 5   

 241   4              Times = 0;
 242   4              shijian = wait_time;
 243   4              Timer0_start = 1; 
 244   4             }
 245   3          }
 246   2          else
 247   2          {
 248   3            i = 1;
 249   3            Timer0_start = 0;  
 250   3          }
 251   2        }
 252   1        CLR_Buf2(); 
 253   1      }
 254          
 255          /*******************************************************************************
 256          * º¯ÊýÃû : Set_Text_Mode
 257          * ÃèÊö   : ÉèÖÃ¶ÌÐÅÎªTEXTÎÄ±¾Ä£Ê½
 258          * ÊäÈë   : 
 259          * Êä³ö   : 
 260          * ·µ»Ø   : 
 261          * ×¢Òâ   : 
 262          *******************************************************************************/
 263          void Set_Text_Mode(void)
 264          {
 265   1      //  unsigned char temp[50]="AT+CSCA=";                  
 266   1        Sec_AT_Command("ATE0","OK",3);                          //È¡Ïû»ØÏÔ              
 267   1        Sec_AT_Command("AT+CNMI=3,2,0,0,0","OK",3);             //ÐÂ¶ÌÐÅÖ±½ÓÊä³ö            
 268   1        Sec_AT_Command("AT+CMGF=1","OK",3);                     //TEXTÄ£Ê½  
 269   1        Sec_AT_Command("AT+CPMS=\"SM\",\"SM\",\"SM\"","OK",3);  //ËùÓÐ²Ù×÷¶¼ÔÚSIM¿¨ÖÐ½øÐÐ 
 270   1      //  strcat(temp,SMS_Num);
 271   1      //  Sec_AT_Command(temp,"OK",3);                            //ÉèÖÃ¶ÌÐÅÖÐÐÄºÅÂë
 272   1      }
 273          
 274          /*******************************************************************************
 275          * º¯ÊýÃû : Check_Message_rec
 276          * ÃèÊö   : ¼ì²éÊÇ·ñÓÐÐÂÐÅÏ¢£¬²¢Ö´ÐÐÐÅÏ¢ÄÚÈÝÖ¸Áî
 277          * ÊäÈë   : 
 278          * Êä³ö   : 
 279          * ·µ»Ø   : 
 280          * ×¢Òâ   : 
 281          *******************************************************************************/
 282          
 283          void Check_New_Message(void)
 284          {
 285   1        u8 temp=0,i;
 286   1        if(strstr(Uart2_Buf,"+CMT")!=NULL)      //Èô»º´æ×Ö·û´®ÖÐº¬ÓÐ"+CMT"¾Í±íÊ¾ÓÐÐÂµÄ¶ÌÐÅ
 287   1        {
 288   2          delay_ms(50);//µÈ´ýÊý¾ÝÈ«²¿½ÓÊÕÍê³É
 289   2          UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:\r\n");
 290   2          UART1_SendString(Uart2_Buf);      //°ÑÄ£¿é·µ»ØµÄÐÅÏ¢Ô­ÑùÊä³ö
 291   2          if(strstr(Uart2_Buf,Password)!=NULL)
 292   2          {
 293   3            if(strstr(Uart2_Buf,"Switch1:on")!=NULL)
 294   3            {
 295   4              UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:Switch1:on\r\n");
 296   4              
 297   4            }
 298   3            if(strstr(Uart2_Buf,"Switch1:off")!=NULL)
 299   3            {
 300   4              UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:Switch1:off\r\n");
 301   4              
 302   4            }
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 6   

 303   3            if(strstr(Uart2_Buf,"Switch2:on")!=NULL)
 304   3            {
 305   4              UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:Switch2:on\r\n");
 306   4              
 307   4            }
 308   3            if(strstr(Uart2_Buf,"Switch2:off")!=NULL)
 309   3            {
 310   4              UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:Switch2:off\r\n");
 311   4              
 312   4            }
 313   3            if(strstr(Uart2_Buf,"Check")!=NULL)
 314   3            {
 315   4              UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:Check\r\n");
 316   4              UART1_SendString(&Uart2_Buf[12]);
 317   4              for(i=0;i<11;i++)
 318   4                  phone[1+i] = Uart2_Buf[12+i];
 319   4              Send_Text_Sms();
 320   4            }
 321   3            if(strstr(Uart2_Buf,"Alter")!=NULL)
 322   3            {
 323   4              UART1_SendString("ÊÕµ½ÐÂ¶ÌÐÅ:Alter\r\n");
 324   4              UART1_SendString(&Uart2_Buf[First_Int-6]);
 325   4              Password[0] = Uart2_Buf[First_Int-6];
 326   4              Password[1] = Uart2_Buf[First_Int-5];
 327   4              Password[2] = Uart2_Buf[First_Int-4];
 328   4              Password[3] = Uart2_Buf[First_Int-3];
 329   4              UART1_SendString(Password);
 330   4              UART1_SendString("ÐÂÃÜÂë\r\n");
 331   4            }
 332   3          }
 333   2          CLR_Buf2();
 334   2          Sec_AT_Command("AT+CMGD=1,1","OK",3);//É¾³ý¶ÌÐÅ
 335   2        }
 336   1      }
 337          
 338          /*******************************************************************************
 339          * º¯ÊýÃû : Wait_CREG
 340          * ÃèÊö   : µÈ´ýÄ£¿é×¢²á³É¹¦
 341          * ÊäÈë   : 
 342          * Êä³ö   : 
 343          * ·µ»Ø   : 
 344          * ×¢Òâ   : 
 345          *******************************************************************************/
 346          void Wait_CREG(void)
 347          {
 348   1        u8 i;
 349   1        u8 k;
 350   1        i = 0;
 351   1        CLR_Buf2();
 352   1        while(i == 0)             
 353   1        {
 354   2          CLR_Buf2();        
 355   2          UART2_SendString("AT+CREG?");
 356   2          UART2_SendLR();
 357   2          delay_ms(5000);             
 358   2            for(k=0;k<Buf2_Max;k++)           
 359   2            {
 360   3            if(Uart2_Buf[k] == ':')
 361   3            {
 362   4              if((Uart2_Buf[k+4] == '1')||(Uart2_Buf[k+4] == '5'))
 363   4              {
 364   5                i = 1;
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 7   

 365   5                UART1_SendLR();
 366   5                break;
 367   5              }
 368   4            }
 369   3          }
 370   2          UART1_SendString("×¢²áÖÐ.....");
 371   2        }
 372   1      }
 373          
 374          void Send_Text_Sms(void)
 375          {
 376   1        unsigned char temp[50]="AT+CMGS=";
 377   1      //  Temp_Change(Ds18b20ReadTemp(),Datas_Buff);
 378   1        strcat(temp,phone); 
 379   1        Sec_AT_Command(temp,">",3); 
 380   1        UART2_SendString(content); 
 381   1        UART2_SendString(Datas_Buff); 
 382   1        UART2_SendData(0X1A); 
 383   1        UART2_SendLR(); 
 384   1      }
 385          
 386          void Temp_Change(int temp,unsigned char* Buff)
 387          {
 388   1          float tp;  
 389   1          if(temp< 0)       //µ±ÎÂ¶ÈÖµÎª¸ºÊý
 390   1          {
 391   2            Buff[0] = '-';
 392   2          //ÒòÎª¶ÁÈ¡µÄÎÂ¶ÈÊÇÊµ¼ÊÎÂ¶ÈµÄ²¹Âë£¬ËùÒÔ¼õ1£¬ÔÙÈ¡·´Çó³öÔ­Âë
 393   2          temp=temp-1;
 394   2          temp=~temp;
 395   2          tp=temp;
 396   2          temp=tp*0.0625*100+0.5; 
 397   2          //ÁôÁ½¸öÐ¡Êýµã¾Í*100£¬+0.5ÊÇËÄÉáÎåÈë£¬ÒòÎªCÓïÑÔ¸¡µãÊý×ª»»ÎªÕûÐÍµÄÊ±ºò°ÑÐ¡Êýµã
 398   2          //ºóÃæµÄÊý×Ô¶¯È¥µô£¬²»¹ÜÊÇ·ñ´óÓÚ0.5£¬¶ø+0.5Ö®ºó´óÓÚ0.5µÄ¾ÍÊÇ½ø1ÁË£¬Ð¡ÓÚ0.5µÄ¾Í
 399   2          //ËãÓÉÏ0.5£¬»¹ÊÇÔÚÐ¡ÊýµãºóÃæ¡£
 400   2          }
 401   1        else
 402   1          { 
 403   2          Buff[0] = '+';      
 404   2          tp=temp;//ÒòÎªÊý¾Ý´¦ÀíÓÐÐ¡ÊýµãËùÒÔ½«ÎÂ¶È¸³¸øÒ»¸ö¸¡µãÐÍ±äÁ¿
 405   2          //Èç¹ûÎÂ¶ÈÊÇÕýµÄÄÇÃ´£¬ÄÇÃ´ÕýÊýµÄÔ­Âë¾ÍÊÇ²¹ÂëËü±¾Éí
 406   2          temp=tp*0.0625*100+0.5; 
 407   2          //ÁôÁ½¸öÐ¡Êýµã¾Í*100£¬+0.5ÊÇËÄÉáÎåÈë£¬ÒòÎªCÓïÑÔ¸¡µãÊý×ª»»ÎªÕûÐÍµÄÊ±ºò°ÑÐ¡Êýµã
 408   2          //ºóÃæµÄÊý×Ô¶¯È¥µô£¬²»¹ÜÊÇ·ñ´óÓÚ0.5£¬¶ø+0.5Ö®ºó´óÓÚ0.5µÄ¾ÍÊÇ½ø1ÁË£¬Ð¡ÓÚ0.5µÄ¾Í
 409   2          //Ëã¼ÓÉÏ0.5£¬»¹ÊÇÔÚÐ¡ÊýµãºóÃæ¡£
 410   2          }
 411   1        Buff[1] = temp / 10000 + 0x30;
 412   1        Buff[2] = temp % 10000 / 1000 + 0x30;
 413   1        Buff[3] = temp % 1000 / 100 + 0x30;
 414   1        Buff[4] = '.';  
 415   1        Buff[5] = temp % 100 / 10 + 0x30;
 416   1        Buff[6] = temp % 10 + 0x30;
 417   1      }
 418          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1530    ----
   CONSTANT SIZE    =    517    ----
   XDATA SIZE       =    274    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      80
C51 COMPILER V9.59.0.0   MAIN                                                              03/06/2019 16:42:13 PAGE 8   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
